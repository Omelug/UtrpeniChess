<!DOCTYPE html>
<html lang="cz">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../static/index.css ">
    <link rel="stylesheet" href="../static/board.css ">
    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
    <title>Board</title>

</head>
<body>
<div class="mainDiv">
    <div class="board_info">
        <p id="player">Player uuid: {{player_uuid}}</p>
        <div class="game-info-container">
            <p id="game">Game code: {{game_code}}</p>
            <p id="turn">Turn: </p>
        </div>
    </div>

    <div class="container-gameboard">
        <div id="chessboard">

        </div>
    </div>

    <div id="chatContainer"></div>

</div>
<script>
    document.addEventListener('DOMContentLoaded', function () {
        fetchInitialMap();
        var socket_io = io('http://127.0.0.1:5000');
        socket_io.on('turn_move', function (data) {
            console.log("awdwadaw")
            transformSvg(data.from.x, data.from.y, data.to.x, data.to.y)
        })
    });

    let gameMap = {};
    const chessboard = document.getElementById('chessboard');
    const cellSize = 50;

    async function fetchInitialMap() {
        try {
            const response = await fetch('/get_map');
            if (!response.ok) {
                throw new Error(`HTTP error! Status: ${response.status}`);
            }
            gameMap = await response.json();
            renderChessboard(gameMap);
        } catch (error) {
            console.error('Error fetching initial game map:', error);
        }
    }

    function hexToRgb(hex) {
        const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
        hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);

        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
            r: parseInt(result[1], 16),
            g: parseInt(result[2], 16),
            b: parseInt(result[3], 16)
        } : null;
    }

    function transformSvg(row, col, newRow, newCol) {
        const selector = `svg[pos_x="${col}"][pos_y="${row}"]`;
        const pieceSvg = document.querySelector(selector);
        pieceSvg.setAttribute('pos_x', col);
        pieceSvg.setAttribute('pos_y', row);

        if (pieceSvg) {
            pieceSvg.style.transform = `translate(${newCol * cellSize}px, ${newRow * cellSize}px)`;
        } else {
            console.error(`No SVG found at position (${col}, ${row})`);
        }
    }

    function generateFilterValues(rgb) {
        const { r, g, b } = rgb;
        // Calculating the necessary CSS filter values to match the hex color
        // This requires some experimentation and fine-tuning
        const brightness = (r + g + b) / 3 / 255;
        const invert = brightness > 0.5 ? 1 : 0;
        const sepia = 1;
        const saturate = 100;
        const hueRotate = 0;
        const contrast = 1;

        // Adjusting brightness and contrast to match the target color
        const adjustedBrightness = 1 + (brightness - 0.5) * 2;
        const adjustedContrast = 1 + (contrast - 0.5) * 2;

        return `invert(${invert}) sepia(${sepia}) saturate(${saturate}%) hue-rotate(${hueRotate}deg) brightness(${adjustedBrightness}) contrast(${adjustedContrast})`;
    }

    let selectedRow = -1, selectedCol = -1, targetRow = -1, targetCol = -1;

    function renderChessboard(data) {
        chessboard.innerHTML = '';
        const boardSize = data.start.size;

        const chessboardWidth = boardSize * cellSize;

        chessboard.style.width = `${chessboardWidth}px`;
        chessboard.style.height = `${chessboardWidth}px`;
        chessboard.style.position = 'relative';

        const turnDiv = document.getElementById('turn');
        turnDiv.textContent = 'Turn: ' + data.status.turn;

        for (let row = 0; row < boardSize; row++) {
            for (let col = 0; col < boardSize; col++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');
                cell.classList.add('cell');
                cell.setAttribute('data-row', row);
                cell.setAttribute('data-col', col);
                cell.style.width = `${cellSize}px`;
                cell.style.height = `${cellSize}px`;

                if ((row + col) % 2 === 0) {
                    cell.classList.add('light');
                } else {
                    cell.classList.add('dark');
                }
                chessboard.appendChild(cell);
                cell.addEventListener('click', () => {
                    if (selectedRow === -1 && selectedCol === -1) {
                        cell.classList.add('selected');
                        cell.style.background = 'green';
                        selectedRow = row;
                        selectedCol = col;
                    } else if (targetRow === -1 && targetCol === -1) {

                        turn(selectedRow, selectedCol, row, col);

                        const previousSelectedCell = document.querySelector('.cell.selected');
                        if (previousSelectedCell) {
                            previousSelectedCell.style.background = '';
                            previousSelectedCell.classList.remove('selected');
                        }

                        selectedRow = -1;
                        selectedCol = -1;
                        targetRow = -1;
                        targetCol = -1;
                    }
                });

                const piece = findPieceAtPosition(data, row, col);
                if (piece) {
                    const pieceSvg = document.createElement('svg');
                    pieceSvg.style.position = 'absolute';

                    pieceSvg.style.width = `${cellSize}px`;
                    pieceSvg.style.height = `${cellSize}px`;
                    pieceSvg.setAttribute('pos_x', col);
                    pieceSvg.setAttribute('pos_y', row);
                    pieceSvg.style.top ="0";
                    pieceSvg.style.left = "0";

                    pieceSvg.style.backgroundImage = `url("../static/figures/${data.start.fig_style}/${piece.fig_type}.svg")`;
                    pieceSvg.style.backgroundSize = 'contain';
                    pieceSvg.style.backgroundRepeat = 'no-repeat';
                    pieceSvg.style.backgroundPosition = 'center';
                    pieceSvg.style.pointerEvents = 'none';

                    //TODO not doning every time, set json
                    const colorHex = data.start.colors[piece.color];
                    const rgb = hexToRgb(colorHex);
                    pieceSvg.style.filter = generateFilterValues(rgb);

                    pieceSvg.style.transform = `translate(${col * cellSize}px, ${row * cellSize}px)`;

                    chessboard.appendChild(pieceSvg);
                }
            }
        }
    }

    function turn(selectedRow, selectedCol, targetRow, targetCol) {
        const postData = {
            from: { x: selectedRow, y: selectedCol },
            to: { x: targetRow, y: targetCol },
        };
        fetch('/turn', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(postData),
        })
        .then(response => response.json())
        .then(data => {
            console.log('Turn error:', data.error);
        })
        .catch(error => {
            console.error('Error:', error);
        });
    }

    function findPieceAtPosition(data, row, col) {
        return data.status.figures.find(piece => piece.x === row && piece.y === col) || null;
    }

    function loadChat() {
        fetch('/chat')
            .then(response => response.text()).then(data => {
            document.getElementById('chatContainer').innerHTML = data;
            const scripts = document.getElementById('chatContainer').getElementsByTagName('script');
            for (let script of scripts) {eval(script.innerHTML);}})
        .catch(error => console.error('Error loading chat:', error));
    }
    document.addEventListener('DOMContentLoaded', loadChat);
</script>
</body>
</html>