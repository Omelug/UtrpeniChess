<!DOCTYPE html>
<html lang="cz">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../static/index.css ">
    <link rel="stylesheet" href="../static/board.css ">
    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
    <title>Board</title>

</head>
<body>
<div class="mainDiv">
    <div class="board_info">
        <p id="player">PLayer uuid: {{player_uuid}}</p>
        <div class="game-info-container">
            <p id="game">Game code: {{game_code}}</p>
            <p id="turn">Turn: </p>
        </div>
    </div>

    <div class="container-gameboard">
        <div id="chessboard">

        </div>
    </div>

    <div id="chatContainer"></div>

</div>
<script>
        let gameMap = {};
        const chessboard = document.getElementById('chessboard');

        async function fetchInitialMap() {
            try {
                const response = await fetch('/get_map');
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                gameMap = await response.json();
                renderChessboard(gameMap);
            } catch (error) {
                console.error('Error fetching initial game map:', error);
            }
        }
        fetchInitialMap();

        function renderChessboard(data) {
        chessboard.innerHTML = '';
        console.log('Render:', gameMap);

        const boardSize = data.start.size;
        const cellSize = 50;

        const chessboardWidth = boardSize * cellSize;

        chessboard.style.width = `${chessboardWidth}px`;
        chessboard.style.height = `${chessboardWidth}px`;
        chessboard.style.gridTemplateColumns = `repeat(${boardSize}, ${cellSize}px)`;
        chessboard.style.gridTemplateRows = `repeat(${boardSize}, ${cellSize}px)`;

        const turnDiv = document.getElementById('turn');
        turnDiv.textContent = 'Turn: ' + data.status.turn;

        for (let row = 0; row < boardSize; row++) {
            for (let col = 0; col < boardSize; col++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');

                if ((row + col) % 2 === 0) {
                    cell.classList.add('light');
                } else {
                    cell.classList.add('dark');
                }

                cell.style.width = `${cellSize}px`;
                cell.style.height = `${cellSize}px`;

                const piece = findPieceAtPosition(data, row, col);
                if (piece) {
                    const pieceDiv = document.createElement('div');
                    console.log('Piece:', piece) //TODO tohle nefunguje
                    pieceDiv.textContent = getPieceSymbol(piece.type);
                    //pieceDiv.style.color = piece.color === 'white' ? data.start.colors.white : data.start.colors.black;
                    cell.appendChild(pieceDiv);
                }

                chessboard.appendChild(cell);
            }
        }
    }

    function findpieceatposition(data, row, col) {
        for (const player of Object.values(data.status.players)) {
            for (const pieces of Object.values(player.figures)) {
                for (const piece of pieces) {
                    const [pieceRow, pieceCol] = piece.position;
                    if (pieceRow === row && pieceCol === col) {
                        return { type: Object.keys(pieces)[0]};
                    }
                }
            }
        }
        return null;
    }

    function getPieceSymbol(type) {
        // Implement your logic to return symbols (e.g., ♟ for pawn, ♚ for king)
        switch (type) {
            case 'pawn':
                return '♟';
            case 'tower':
                return '♜';
            case 'bishop':
                return '♝';
            case 'horse':
                return '♞';
            case 'queen':
                return '♛';
            case 'king':
                return '♚';
            default:
                return '';
        }
    }

        function loadChat() {
            fetch('/chat')
            .then(response => response.text())
            .then(data => {
                document.getElementById('chatContainer').innerHTML = data;
                const scripts = document.getElementById('chatContainer').getElementsByTagName('script');
                for (let script of scripts) {
                    eval(script.innerHTML);
                }
            })
            .catch(error => console.error('Error loading chat:', error));
        }
        document.addEventListener('DOMContentLoaded', loadChat);
    </script>

</body>
</html>