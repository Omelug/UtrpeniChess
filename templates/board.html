<!DOCTYPE html>
<html lang="cz">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../static/index.css ">
    <link rel="stylesheet" href="../static/board.css ">
    <script src="https://cdn.socket.io/4.0.0/socket.io.min.js"></script>
    <title>Board</title>

</head>
<body>
<div class="mainDiv">
    <div class="board_info">
        <p id="player">Player uuid: {{player_uuid}}</p>
        <div class="game-info-container">
            <p id="game">Game code: {{game_code}}</p>
            <p id="turn">Turn: </p>
        </div>
    </div>

    <div class="container-gameboard">
        <div id="chessboard">

        </div>
    </div>

    <div id="chatContainer"></div>

</div>
<script>
        let gameMap = {};
        const chessboard = document.getElementById('chessboard');

        async function fetchInitialMap() {
            try {
                const response = await fetch('/get_map');
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                gameMap = await response.json();
                renderChessboard(gameMap);
            } catch (error) {
                console.error('Error fetching initial game map:', error);
            }
        }
        fetchInitialMap();

        function hexToRgb(hex) {
            const shorthandRegex = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
            hex = hex.replace(shorthandRegex, (m, r, g, b) => r + r + g + g + b + b);

            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : null;
        }

        function generateFilterValues(rgb) {
        const { r, g, b } = rgb;
        // Calculating the necessary CSS filter values to match the hex color
        // This requires some experimentation and fine-tuning
        const brightness = (r + g + b) / 3 / 255;
        const invert = brightness > 0.5 ? 0 : 1;
        const sepia = 1;
        const saturate = 100;
        const hueRotate = 0;
        const contrast = 1;

        // Adjusting brightness and contrast to match the target color
        const adjustedBrightness = 1 + (brightness - 0.5) * 2;
        const adjustedContrast = 1 + (contrast - 0.5) * 2;

        return `invert(${invert}) sepia(${sepia}) saturate(${saturate}%) hue-rotate(${hueRotate}deg) brightness(${adjustedBrightness}) contrast(${adjustedContrast})`;
    }

        [selectedRow, selectedCol, targetRow, targetCol] = [-1, -1, -1, -1];

        function renderChessboard(data) {
        chessboard.innerHTML = '';
        console.log('Render:', gameMap);

        const boardSize = data.start.size;
        const cellSize = 50;

        const chessboardWidth = boardSize * cellSize;

        chessboard.style.width = `${chessboardWidth}px`;
        chessboard.style.height = `${chessboardWidth}px`;
        chessboard.style.gridTemplateColumns = `repeat(${boardSize}, ${cellSize}px)`;
        chessboard.style.gridTemplateRows = `repeat(${boardSize}, ${cellSize}px)`;

        const turnDiv = document.getElementById('turn');
        turnDiv.textContent = 'Turn: ' + data.status.turn;

        for (let row = 0; row < boardSize; row++) {
            for (let col = 0; col < boardSize; col++) {
                const cell = document.createElement('div');
                cell.classList.add('cell');

                if ((row + col) % 2 === 0) {
                    cell.classList.add('light');
                } else {
                    cell.classList.add('dark');
                }

                cell.style.width = `${cellSize}px`;
                cell.style.height = `${cellSize}px`;

                const piece = findPieceAtPosition(data, row, col);
                console.log('Piece:', piece);
                if (piece) {
                    const pieceDiv = document.createElement('div');

                    pieceDiv.style.width = '100%';
                    pieceDiv.style.height = '100%';
                    pieceDiv.style.backgroundImage = `url("../static/figures/${data.start.fig_style}/${piece.fig_type}.svg")`;
                    pieceDiv.style.backgroundSize = 'contain';
                    pieceDiv.style.backgroundRepeat = 'no-repeat';
                    pieceDiv.style.backgroundPosition = 'center';

                    const colorHex = data.start.colors[piece.color];
                    const rgb = hexToRgb(colorHex);
                    console.log('RGB:', rgb)
                    const filterValues = generateFilterValues(rgb);
                    console.log('filterValues:', filterValues)

                    pieceDiv.style.filter = filterValues;
                    cell.appendChild(pieceDiv);
                }

                cell.addEventListener('click', () => {
                    if (selectedRow === -1 && selectedCol === -1) {
                        cell.classList.add('selected');
                        [selectedRow, selectedCol] = [row, col];
                    } else if (targetRow === -1 && targetCol === -1) {
                        cell.classList.add('target');
                        [targetRow, targetCol] = [row, col];
                        turn(selectedRow, selectedCol, targetRow, targetCol);
                        [selectedRow, selectedCol, targetRow, targetCol] = [-1, -1, -1, -1];

                    } else {
                        const previousSelectedCell = document.querySelector('.cell.selected');
                        const previousTargetCell = document.querySelector('.cell.target');
                        if (previousSelectedCell) {
                            previousSelectedCell.classList.remove('selected');
                        }
                        if (previousTargetCell) {
                            previousTargetCell.classList.remove('target');
                        }

                        cell.classList.add('selected');
                        selectedRow = row;
                        selectedCol = col;
                        targetRow = -1;
                        targetCol = -1;
                    }
                });

                chessboard.appendChild(cell);
            }
        }
    }

    function turn(selectedRow, selectedCol, targetRow, targetCol) {
    const postData = {
        from: { row: selectedRow, col: selectedCol },
        to: { row: targetRow, col: targetCol },
    };
    fetch('/turn', {
        method: 'POST',
        headers: {
            'Content-Type': 'application/json',
        },
        body: JSON.stringify(postData),
    })
    .then(response => response.json())
    .then(data => {
        //TODO  Handle response as needed
    })
    .catch(error => {
        console.error('Error:', error);
    });
}

    function findPieceAtPosition(data, row, col) {
        for (const piece of data.status.figures) {
            if (piece.x === row && piece.y === col) {
                return piece;
            }
        }
        return null;
    }

        function loadChat() {
            fetch('/chat')
            .then(response => response.text())
            .then(data => {
                document.getElementById('chatContainer').innerHTML = data;
                const scripts = document.getElementById('chatContainer').getElementsByTagName('script');
                for (let script of scripts) {
                    eval(script.innerHTML);
                }
            })
            .catch(error => console.error('Error loading chat:', error));
        }
        document.addEventListener('DOMContentLoaded', loadChat);
    </script>

</body>
</html>